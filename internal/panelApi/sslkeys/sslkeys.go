package sslkeys

import (
	"crypto/x509"
	"fmt"
	"math"
	"path/filepath"

	"github.com/gofiber/fiber/v2"
	"github.com/izetmolla/proxymanager/config"
	"github.com/izetmolla/proxymanager/models"
	"github.com/izetmolla/proxymanager/nginx"
	"github.com/izetmolla/proxymanager/utils"
)

func GetSslKeysList(c *fiber.Ctx) error {
	var total int64 = 0
	paginate := utils.GetPaginateParams(c.Query("pageIndex", "0"), c.Query("pageSize", "10"), c.Query("sortBy", "created_at.DESC"))
	query := c.Query("query", "")
	filterStatus := c.Query("status", "") // Default to empty (no filtering)
	db := config.DB.Model(&models.SslKey{})

	// Apply status filter if provided
	if len(filterStatus) > 0 {
		db = db.Where("status = ?", filterStatus)
	}

	// Apply name filter if provided
	if len(query) > 0 {
		db = db.Where("name LIKE ?", "%"+query+"%")
	}

	// Get the total count before applying pagination
	db.Count(&total)
	sslkeys := []models.SslKey{}
	if res := db.
		Offset(paginate.Offset).
		Limit(paginate.PageSize).
		Order(paginate.SortBy + " " + paginate.SortOrder).
		Preload("ProxyHosts").
		Find(&sslkeys); res.Error != nil {
		return c.JSON(utils.Em(res.Error))
	}

	nn := make([]map[string]interface{}, len(sslkeys))
	for i := 0; i < len(sslkeys); i++ {
		nn[i] = map[string]interface{}{
			"id":   sslkeys[i].ID,
			"name": sslkeys[i].Name,
			"type": sslkeys[i].Type,
		}
	}

	return c.JSON(fiber.Map{
		"data":      nn,
		"rowCount":  total,
		"pageCount": int(math.Ceil(float64(total) / float64(paginate.PageSize))),
	})
}

type CreateSslKeyRequest struct {
	Name           string   `json:"name"`
	Type           string   `json:"ssl_type"`
	Domains        []string `json:"domains"`
	SslKey         string   `json:"ssl_key"`
	SslCertificate string   `json:"ssl_certificate"`
}

func CreateSslKey(c *fiber.Ctx) error {
	var body CreateSslKeyRequest
	if err := c.BodyParser(&body); err != nil {
		return c.JSON(utils.Em(err))
	}
	if body.Type == "auto" {
		if len(body.Domains) == 0 {
			return c.JSON(utils.Emp(fmt.Errorf("domains must be provided"), "domains"))
		}
		ssl, err := createAutoGeneratedSSLKey(body.Name, body.Domains[0])
		if err != nil {
			return c.JSON(utils.Em(err))
		}
		return c.JSON(fiber.Map{
			"data": fiber.Map{
				"id": ssl.ID,
			},
		})
	} else if body.Type == "le" {
		return c.JSON(fiber.Map{
			"data": fiber.Map{
				"id": "1",
			},
		})
	} else if body.Type == "custom" {
		sslItem, err := nginx.IsValidSSLCertificate(body.SslCertificate)
		if err != nil {
			return c.JSON(utils.Emp(err, "ssl_certificate"))
		}
		if err := nginx.IsValidSSLKey(body.SslKey); err != nil {
			return c.JSON(utils.Emp(err, "ssl_key"))
		}
		ssl, err := createCustomSslKey(body.Name, body.SslKey, body.SslCertificate, sslItem)
		if err != nil {
			return c.JSON(utils.Em(err))
		}
		return c.JSON(fiber.Map{
			"data": fiber.Map{
				"id": ssl.ID,
			},
		})
	} else {
		return c.JSON(utils.Em(fmt.Errorf("invalid type")))
	}
}

func createAutoGeneratedSSLKey(name, domain string) (ssl models.SslKey, err error) {
	ssl.Name = name
	ssl.Type = "auto"

	if res := config.DB.Model(&models.SslKey{}).Create(&ssl); res.Error != nil {
		return ssl, res.Error
	}

	if err := nginx.GenerateSelfSSL(domain, filepath.Join(nginx.ConfigPath, "ssl", ssl.ID), "Org"); err != nil {
		return ssl, err
	}
	ssl_key, err := nginx.ReadFromFile(filepath.Join(nginx.ConfigPath, "ssl", ssl.ID, "auto", fmt.Sprintf("%s.crt", domain)))
	if err != nil {
		return ssl, err
	}
	ssl_cert, err := nginx.ReadFromFile(filepath.Join(nginx.ConfigPath, "ssl", ssl.ID, "auto", fmt.Sprintf("%s.crt", domain)))
	if err != nil {
		return ssl, err
	}
	ssl.PrivateKey = ssl_key
	ssl.PublicKey = ssl_cert
	if res := config.DB.Model(&models.SslKey{}).Where("id=?", ssl.ID).Updates(&models.SslKey{
		PrivateKey: ssl_key,
		PublicKey:  ssl_cert,
	}); res.Error != nil {
		return ssl, res.Error
	}

	return ssl, err
}

func createCustomSslKey(name, ssl_key, ssl_cert string, sslItem *x509.Certificate) (ssl models.SslKey, err error) {
	ssl.Name = name
	ssl.PrivateKey = ssl_key
	ssl.PublicKey = ssl_cert
	ssl.Type = "custom"
	ssl.Subject = sslItem.Subject.String()
	ssl.Issuer = sslItem.Issuer.String()
	ssl.NotBefore = sslItem.NotBefore
	ssl.NotAfter = sslItem.NotAfter
	ssl.PublicKeyAlgorithm = sslItem.PublicKeyAlgorithm.String()

	if res := config.DB.Model(&models.SslKey{}).Create(&ssl); res.Error != nil {
		return ssl, res.Error
	}
	if err := nginx.WriteToFile(filepath.Join(nginx.ConfigPath, "ssl", ssl.ID, "custom", "ssl.key"), ssl_key); err != nil {
		return ssl, err
	}
	if err := nginx.WriteToFile(filepath.Join(nginx.ConfigPath, "ssl", ssl.ID, "custom", "ssl.crt"), ssl_cert); err != nil {
		return ssl, err
	}
	return ssl, err
}

func DeleteSSLKey(c *fiber.Ctx) error {
	id := c.Query("id")
	if id == "" {
		return c.JSON(utils.Emp(fmt.Errorf("id is required"), "id"))
	}
	if res := config.DB.Where("id=?", id).Delete(&models.SslKey{}); res.Error != nil {
		return c.JSON(utils.Em(res.Error))
	}
	return c.JSON(fiber.Map{
		"data": fiber.Map{
			"id": id,
		},
	})
}

func DownloadSslKey(c *fiber.Ctx) error {
	id := c.Query("id")

	return c.JSON(fiber.Map{
		"data": fiber.Map{"id": id},
	})
}

func SearchKeys(c *fiber.Ctx) error {
	query := c.Query("name", "")
	keys := []models.SslKey{}
	if res := config.DB.Model(&models.SslKey{}).Where("name LIKE ?", "%"+query+"%").Limit(20).Find(&keys); res.Error != nil {
		return c.JSON(utils.Em(res.Error))
	}
	nn := make([]map[string]interface{}, len(keys))
	for i := 0; i < len(keys); i++ {
		nn[i] = map[string]interface{}{
			"value": keys[i].ID,
			"label": fmt.Sprintf("%s (%s)", keys[i].Name, keys[i].Type),
		}
	}
	return c.JSON(fiber.Map{
		"data": nn,
	})
}
